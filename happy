/*
Count Pairs
Given an array of integers 
A
A, and an integer 
K
K find a number of happy elements.

Element 
X
X is happy if there exists at least 
1
1 element whose difference is less than 
K
K i.e. an element 
X
X is happy if there is another element in the range 
[
X
−
K
,
 
X
+
K
]
[X−K, X+K] other than 
X
X itself.

Input Format
The first line contains two integers 
N
N and 
K
K where 
N
N is the size of the array and 
K
K is a number as described above. The second line contains 
N
N integers separated by space.

Output Format
Print a single integer denoting the total number of happy elements.

Constraints
1
≤
N
≤
10
5
1≤N≤10 
5
 
0
≤
K
≤
10
5
0≤K≤10 
5
 
0
≤
A
[
i
]
≤
10
9
0≤A[i]≤10 
9
 
Sample 1:
Input
Output
6 3
5 5 7 9 15 2
5
Explanation:
Other than number 
15
15, everyone has at least 
1
1 element in the range 
[
X
−
3
,
X
+
3
]
[X−3,X+3]. Hence they are all happy elements. Since these five are in number, the output is 
5
5.

Sample 2:
Input
Output
3 2
1 3 5
3
Explanation:
All numbers have at least 
1
1 element in the range 
[
X
−
2
,
 
X
+
2
]
[X−2, X+2]. Hence they are all happy elements. Since these three are in number, the output is 
3
3.
*/


#include <bits/stdc++.h>

using namespace std;

int main() {
    // your code goes here
    int n, k;
    cin >> n >> k;
    vector < int > nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    int c = 0;
    sort(nums.begin(), nums.end());
    for (int i = 0; i < n; i++) {
        int x = nums[i];

        // Range to check: [x-k, x+k], excluding x
        auto it1 = lower_bound(nums.begin(), nums.end(), x - k);
        auto it2 = upper_bound(nums.begin(), nums.end(), x + k);

        // Count how many numbers lie in [x-k, x+k]
        int cnt = it2 - it1;

        // Exclude x itself
        auto it3 = lower_bound(nums.begin(), nums.end(), x);
        auto it4 = upper_bound(nums.begin(), nums.end(), x);
        int x_count = it4 - it3;

        cnt -= x_count;


        if (cnt > 0) c++;
    }
    cout << c << endl;
    return 0;
}
